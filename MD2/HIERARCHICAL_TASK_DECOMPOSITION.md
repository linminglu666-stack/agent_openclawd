# 层次化任务分解与依赖DAG执行

## 文档说明

本文档补充MD2方案中缺失的层次化任务分解与依赖DAG执行机制，基于训练总结P006_R34的深度分析，提供可落地的设计方案。

---

## 一、核心概念

### 1.1 层次化任务分解

层次化任务分解是一种将复杂任务逐层拆解为更小、更易管理子任务的认知策略。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      任务分解层次模型                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Level 0: 战略目标 (Strategic Goal)                                     │
│      ↓ 分解                                                             │
│  Level 1: 战术任务 (Tactical Tasks)                                     │
│      ↓ 分解                                                             │
│  Level 2: 操作步骤 (Operational Steps)                                  │
│      ↓ 分解                                                             │
│  Level 3: 原子动作 (Atomic Actions)                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 分解原则

| 原则 | 描述 | 验证方法 |
|------|------|---------|
| **MECE** | 相互独立，完全穷尽 | 检查子任务是否重叠、是否覆盖所有情况 |
| **单一职责** | 每个子任务只负责一个明确的输出 | 检查子任务是否有多个输出 |
| **可验证性** | 每个子任务的完成状态可被客观验证 | 定义明确的完成条件 |
| **粒度适中** | 子任务既不能太粗也不能太细 | 执行时间在合理范围内 |

### 1.3 依赖DAG基础

有向无环图（DAG）是任务依赖关系的最优数学抽象：

| 元素 | 含义 |
|------|------|
| **节点（Nodes）** | 表示单个任务 |
| **有向边（Directed Edges）** | 表示任务间的依赖关系 |
| **无环性（Acyclic）** | 保证不存在循环依赖，确保执行可终止 |

---

## 二、依赖类型分析

### 2.1 四种基本依赖类型

```
依赖类型:
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  1. 完成-开始 (Finish-to-Start, FS)                                     │
│     ┌─────────┐        ┌─────────┐                                     │
│     │ Task A  │ ────→  │ Task B  │                                     │
│     │ (完成)   │        │ (开始)   │                                     │
│     └─────────┘        └─────────┘                                     │
│     示例: 编码完成后才能测试                                             │
│                                                                         │
│  2. 开始-开始 (Start-to-Start, SS)                                      │
│     ┌─────────┐        ┌─────────┐                                     │
│     │ Task A  │ ────→  │ Task B  │                                     │
│     │ (开始)   │        │ (开始)   │                                     │
│     └─────────┘        └─────────┘                                     │
│     示例: 开发开始后可同步写文档                                          │
│                                                                         │
│  3. 完成-完成 (Finish-to-Finish, FF)                                    │
│     ┌─────────┐        ┌─────────┐                                     │
│     │ Task A  │ ────→  │ Task B  │                                     │
│     │ (完成)   │        │ (完成)   │                                     │
│     └─────────┘        └─────────┘                                     │
│     示例: 子模块完成后父模块才能完成                                       │
│                                                                         │
│  4. 开始-完成 (Start-to-Finish, SF)                                     │
│     ┌─────────┐        ┌─────────┐                                     │
│     │ Task A  │ ────→  │ Task B  │                                     │
│     │ (开始)   │        │ (完成)   │                                     │
│     └─────────┘        └─────────┘                                     │
│     示例: 极少使用                                                        │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 关键路径分析

关键路径是DAG中从开始到结束的最长路径，决定了整个任务集的最短完成时间。

```
关键路径示例:
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│         ┌→ Task B (2h) ─┐                                              │
│ Task A →├→ Task C (3h) ─┼→ Task E (2h)                                 │
│ (1h)    └→ Task D (1h) ─┘                                              │
│                                                                         │
│ 关键路径: Task A → Task C → Task E = 1h + 3h + 2h = 6h                 │
│ 非关键任务: Task B (浮动时间=1h), Task D (浮动时间=3h)                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 三、任务管理系统架构

### 3.1 核心组件

```
Task Manager Core:
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                  │
│  │   Parser     │  │  Scheduler   │  │   Executor   │                  │
│  │   (解析器)    │  │   (调度器)    │  │   (执行器)    │                  │
│  └──────────────┘  └──────────────┘  └──────────────┘                  │
│                                                                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                  │
│  │  Dependency  │  │   State      │  │   Monitor    │                  │
│  │    Graph     │  │   Store      │  │   (监控器)    │                  │
│  │   (依赖图)    │  │  (状态存储)   │  │              │                  │
│  └──────────────┘  └──────────────┘  └──────────────┘                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 组件职责

| 组件 | 职责 | 输入 | 输出 |
|------|------|------|------|
| **Parser** | 解析任务描述，生成任务对象 | 自然语言/结构化描述 | Task对象 |
| **Scheduler** | 根据依赖关系调度任务执行 | DAG、资源状态 | 执行计划 |
| **Executor** | 执行具体任务 | Task、执行计划 | 执行结果 |
| **Dependency Graph** | 维护任务依赖关系 | 任务变更 | 依赖图状态 |
| **State Store** | 持久化任务状态 | 状态变更 | 持久化状态 |
| **Monitor** | 监控执行进度和健康状态 | 执行事件 | 监控报告 |

---

## 四、状态机设计

### 4.1 任务生命周期状态

```
任务状态机:
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│                    ┌──────────┐                                        │
│                    │  PENDING │ (等待依赖满足)                          │
│                    └────┬─────┘                                        │
│                         │ 依赖满足                                      │
│                         ▼                                               │
│                    ┌──────────┐                                        │
│                    │  READY   │ (准备执行)                              │
│                    └────┬─────┘                                        │
│                         │ 开始执行                                      │
│                         ▼                                               │
│              ┌────────────────────┐                                    │
│              │     RUNNING        │ (执行中)                            │
│              └─────────┬──────────┘                                    │
│                        │                                                │
│           ┌────────────┼────────────┐                                  │
│           ▼            ▼            ▼                                  │
│      ┌────────┐  ┌──────────┐  ┌──────────┐                           │
│      │SUCCESS │  │  FAILED  │  │ CANCELLED│                           │
│      └───┬────┘  └────┬─────┘  └──────────┘                           │
│          │            │                                                │
│          ▼            ▼                                                │
│    ┌──────────┐  ┌──────────┐                                         │
│    │  NOTIFY  │  │  RETRY?  │                                         │
│    │  下游任务 │  │  重试策略 │                                         │
│    └──────────┘  └──────────┘                                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 状态转换规则

| 当前状态 | 触发条件 | 目标状态 | 副作用 |
|---------|---------|---------|--------|
| PENDING | 所有依赖完成 | READY | 加入就绪队列 |
| READY | 资源可用 | RUNNING | 分配资源 |
| RUNNING | 执行成功 | SUCCESS | 释放资源，通知下游 |
| RUNNING | 执行失败 | FAILED | 释放资源，触发重试策略 |
| RUNNING | 取消请求 | CANCELLED | 释放资源 |
| FAILED | 重试次数未达上限 | READY | 加入就绪队列 |
| FAILED | 重试次数已达上限 | FAILED | 终态，通知下游失败 |

---

## 五、调度算法

### 5.1 拓扑排序算法

```
Kahn算法 (BFS-based):
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  function topological_sort_kahn(graph):                                │
│      # 1. 计算入度                                                      │
│      in_degree = {node: 0 for node in graph.nodes}                     │
│      for node in graph.nodes:                                          │
│          for neighbor in graph.neighbors(node):                        │
│              in_degree[neighbor] += 1                                  │
│                                                                         │
│      # 2. 初始化队列（入度为0的节点）                                    │
│      queue = deque([node for node in graph.nodes                       │
│                     if in_degree[node] == 0])                          │
│      result = []                                                        │
│                                                                         │
│      # 3. BFS遍历                                                       │
│      while queue:                                                       │
│          node = queue.popleft()                                        │
│          result.append(node)                                           │
│          for neighbor in graph.neighbors(node):                        │
│              in_degree[neighbor] -= 1                                  │
│              if in_degree[neighbor] == 0:                              │
│                  queue.append(neighbor)                                │
│                                                                         │
│      # 4. 检测循环依赖                                                  │
│      if len(result) != len(graph.nodes):                               │
│          raise CyclicDependencyError()                                 │
│                                                                         │
│      return result                                                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.2 并行调度策略

```
并行调度器:
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  class ParallelScheduler:                                              │
│      """并行任务调度器"""                                                │
│                                                                         │
│      def __init__(self, max_parallelism: int):                         │
│          self.max_parallelism = max_parallelism                        │
│          self.resource_manager = ResourceManager()                     │
│                                                                         │
│      async def schedule(self, dag: DAG) -> ExecutionPlan:              │
│          # 1. 拓扑排序                                                  │
│          topo_order = self.topological_sort(dag)                       │
│                                                                         │
│          # 2. 计算关键路径                                              │
│          critical_path = self.compute_critical_path(dag)               │
│                                                                         │
│          # 3. 生成并行执行计划                                           │
│          execution_plan = []                                            │
│          ready_tasks = []                                               │
│          running_tasks = []                                             │
│                                                                         │
│          for task in topo_order:                                        │
│              # 等待资源可用                                              │
│              while len(running_tasks) >= self.max_parallelism:         │
│                  completed = await self.wait_for_completion()           │
│                  running_tasks.remove(completed)                        │
│                  ready_tasks = self.update_ready_tasks(dag, completed)  │
│                                                                         │
│              # 选择最高优先级的就绪任务                                  │
│              if task in ready_tasks or self.can_start(task, dag):      │
│                  if self.resource_manager.allocate(task):              │
│                      execution_plan.append(task)                       │
│                      running_tasks.append(task)                        │
│                                                                         │
│          return execution_plan                                          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.3 资源感知调度

| 约束类型 | 描述 | 处理策略 |
|---------|------|---------|
| **CPU约束** | 任务需要特定CPU核心数 | 资源池管理，按需分配 |
| **内存约束** | 任务需要特定内存量 | 内存配额管理 |
| **IO约束** | 任务有IO瓶颈 | IO密集型任务并行化 |
| **时间约束** | 任务有截止时间 | 优先级调度，截止时间排序 |
| **亲和性约束** | 任务需在特定节点执行 | 节点标签匹配 |

---

## 六、设计模式与反模式

### 6.1 设计模式

```
设计模式:
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  1. 任务链模式 (Task Chain Pattern)                                     │
│     适用: 线性依赖的任务序列                                             │
│     Task A → Task B → Task C → Task D                                  │
│     示例: 数据处理流水线、构建流程                                       │
│                                                                         │
│  2. 扇出-扇入模式 (Fan-out/Fan-in)                                      │
│     适用: 并行处理后聚合的场景                                           │
│              ┌→ Task B ─┐                                              │
│     Task A → ┼→ Task C ─┼→ Task E                                      │
│              └→ Task D ─┘                                              │
│     示例: MapReduce计算、并行API调用                                     │
│                                                                         │
│  3. 守卫模式 (Guard Pattern)                                            │
│     适用: 条件分支执行                                                   │
│     Task A → [Condition] → Task B (if true)                            │
│                         → Task C (if false)                            │
│     示例: 特性开关、环境判断                                              │
│                                                                         │
│  4. 补偿模式 (Compensation Pattern)                                     │
│     适用: 需要回滚的场景                                                 │
│     Task A → Task B → Task C (失败) → Compensate B → Compensate A      │
│     示例: 分布式事务、多步骤操作                                          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.2 反模式

| 反模式 | 描述 | 风险 | 解决方案 |
|--------|------|------|---------|
| **循环依赖** | A→B→C→A | 死锁，无法执行 | 打破循环，引入中间任务 |
| **过度分解** | 任务粒度过细 | 调度开销>执行开销 | 合并小任务 |
| **隐式依赖** | 依赖未显式声明 | 竞态条件，难以调试 | 显式声明所有依赖 |
| **钻石依赖** | A→B, A→C, B→D, C→D | 重复执行 | 使用DAG去重 |
| **阻塞等待** | 长任务阻塞短任务 | 资源浪费 | 优先级调度 |

---

## 七、错误处理机制

### 7.1 失败策略

```
失败策略:
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  策略1: 立即失败 (Fail Fast)                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ • 任一任务失败立即停止整个流程                                    │   │
│  │ • 适用场景: 金融交易、关键操作                                    │   │
│  │ • 优点: 快速失败，避免无效工作                                    │   │
│  │ • 缺点: 可能丢失部分结果                                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  策略2: 忽略继续 (Ignore and Continue)                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ • 记录失败但继续执行其他任务                                      │   │
│  │ • 适用场景: 批量数据处理、非关键任务                              │   │
│  │ • 优点: 最大化完成率                                              │   │
│  │ • 缺点: 可能产生不完整结果                                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  策略3: 重试策略 (Retry with Backoff)                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ • 失败后按指数退避重试                                            │   │
│  │ • 适用场景: 网络请求、临时故障                                    │   │
│  │ • 参数: 最大重试次数、初始延迟、最大延迟                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  策略4: 补偿事务 (Compensating Transaction)                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ • 失败后执行补偿操作回滚                                          │   │
│  │ • 适用场景: 分布式事务、多步骤操作                                │   │
│  │ • 要求: 每个任务定义补偿操作                                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 7.2 重试策略配置

```json
{
  "retry_policy": {
    "max_attempts": 3,
    "initial_delay_ms": 1000,
    "max_delay_ms": 30000,
    "backoff_multiplier": 2.0,
    "retryable_errors": [
      "TIMEOUT",
      "RESOURCE_UNAVAILABLE",
      "RATE_LIMIT_EXCEEDED"
    ],
    "non_retryable_errors": [
      "VALIDATION_ERROR",
      "PERMISSION_DENIED",
      "NOT_FOUND"
    ]
  }
}
```

---

## 八、与现有系统的集成

### 8.1 与Scheduler模块的集成

```
Scheduler扩展接口:
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  class DAGScheduler:                                                   │
│      """DAG调度器扩展"""                                                │
│                                                                         │
│      def __init__(self):                                               │
│          self.dag_store = DAGStore()                                   │
│          self.task_executor = TaskExecutor()                           │
│          self.dependency_resolver = DependencyResolver()               │
│                                                                         │
│      async def submit_dag(self, dag: TaskDAG) -> str:                 │
│          """提交DAG任务"""                                              │
│          dag_id = self.dag_store.create(dag)                           │
│          await self.schedule_execution(dag_id)                         │
│          return dag_id                                                 │
│                                                                         │
│      async def get_execution_status(self, dag_id: str) -> DAGStatus:  │
│          """获取执行状态"""                                              │
│          return self.dag_store.get_status(dag_id)                      │
│                                                                         │
│      async def cancel_dag(self, dag_id: str) -> bool:                 │
│          """取消DAG执行"""                                              │
│          return await self.dag_store.cancel(dag_id)                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 8.2 与Agent Pool的集成

```
Agent Pool任务分发:
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  class TaskDistributor:                                                │
│      """任务分发器"""                                                   │
│                                                                         │
│      async def distribute_tasks(self, dag: TaskDAG, agents: list):    │
│          """将DAG任务分发到Agent池"""                                    │
│                                                                         │
│          # 1. 分析任务需求                                              │
│          task_requirements = self.analyze_requirements(dag)            │
│                                                                         │
│          # 2. 匹配Agent能力                                             │
│          assignments = {}                                               │
│          for task in dag.tasks:                                        │
│              best_agent = self.find_best_agent(task, agents)           │
│              assignments[task.id] = best_agent                         │
│                                                                         │
│          # 3. 按依赖顺序分发                                            │
│          execution_order = self.topological_sort(dag)                  │
│          for task_id in execution_order:                               │
│              agent = assignments[task_id]                              │
│              await agent.submit_task(dag.get_task(task_id))            │
│                                                                         │
│          return assignments                                             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 九、验收标准

| 指标 | 目标值 | 验证方法 |
|------|--------|---------|
| DAG解析正确率 | 100% | 循环依赖检测测试 |
| 拓扑排序正确性 | 100% | 依赖顺序验证 |
| 并行效率 | ≥80% | 并行加速比测试 |
| 调度延迟 | ≤100ms | 端到端延迟测试 |
| 故障恢复时间 | ≤30s | 故障注入测试 |
| 资源利用率 | ≥70% | 资源监控 |

---

## 十、实施路线图

| 阶段 | 内容 | 交付物 | 周期 |
|------|------|--------|------|
| 1 | DAG解析与验证 | Parser、循环依赖检测 | 1周 |
| 2 | 拓扑排序与调度 | Scheduler、关键路径计算 | 1周 |
| 3 | 并行执行器 | Executor、资源管理 | 1周 |
| 4 | 错误处理机制 | 重试策略、补偿事务 | 1周 |
| 5 | 系统集成 | Agent Pool集成、监控 | 1周 |
| 6 | 测试与优化 | 性能测试、压力测试 | 1周 |

---

**文档版本**: v1.0.0  
**创建时间**: 2026-02-12  
**来源**: 基于训练总结P006_R34深度分析
