1. 术语与对象模型

为支持“Cron 调度 + DAG 执行 + 可视化控制”，建议把对象拆成 4 层（前端也更好做）：

层级	对象	说明
定义层	Workflow(DAG)	DAG 定义本体（节点、边、参数 schema、版本）
调度层	Schedule	Cron 绑定到某个 Workflow 版本/别名，定义触发策略与执行策略
执行层	Run	一次 Workflow 的执行实例（由 Schedule 触发或手动触发）
子执行层	NodeRun	Run 内每个节点的实例状态、日志、重试等

这意味着：你原来“job”概念在可视化里应更像 Schedule；Workflow（DAG）由 OpenClawd 内部已有体系提供或扩展一个注册表。

2. 总体架构（与你的 Flask 控制台后端打通）
2.1 组件职责

openclawd-scheduler（WSL 内系统服务）

维护 Schedule

计算 cron 下一次触发、处理 misfire、并发策略

触发时创建 Run，并投递给 orchestrator（DAG 执行引擎）

提供本机管理 API（建议 Unix socket）

openclawd-orchestrator/executor（DAG 执行引擎）

根据 Run 执行 DAG，生成 NodeRun 状态、日志、心跳、总结

你的 Flask 后端（控制台 BFF，推荐做法）

对前端提供统一 API（鉴权、RBAC、审计、聚合）

向 scheduler/orchestrator 的本机 API 发请求（或读同一数据库）

对前端提供 SSE/WS 事件流（可代理/聚合）

2.2 推荐通信方式

Flask → scheduler：unix:// /run/openclawd/scheduler.sock（安全，不暴露端口）

Flask → orchestrator：同样走 unix socket 或 loopback TCP（127.0.0.1）

前端 → Flask：HTTP/JSON + SSE（优先 SSE，足够好用）

你已有 Flask 后端，因此可以不单独做 scheduler-gateway 服务：由 Flask 直接充当 gateway/BFF，减少一个进程与一套鉴权。

3. 核心交互流程（控制台视角）
3.1 创建/编辑 Schedule（可视化配置）

前端编辑 cron/时区/策略/绑定的 workflow

调用：POST/PUT /api/v1/schedules

保存后列表直接展示：next_fire_at、last_run_status

3.2 定时触发执行（无需控制台参与）

scheduler 到点触发

scheduler 创建 Run（status=scheduled），写入存储

scheduler 投递 Run 给 orchestrator（队列/DB outbox/IPC）

orchestrator 执行，产生 NodeRun、日志与进度事件

完成后写 summary，并发出 run.finished

3.3 控制台实时观察（Run 详情）

前端打开 Run 页面，订阅 GET /api/v1/events?run_id=...（SSE）

实时更新：Run 状态、节点状态、进度心跳、日志尾部、失败原因

3.4 控制台控制（取消/暂停/恢复/重试）

POST /api/v1/runs/{run_id}:cancel

POST /api/v1/runs/{run_id}:pause（语义见后文）

POST /api/v1/runs/{run_id}:resume

POST /api/v1/nodeRuns/{node_run_id}:retry 等

4. API 规范（给 Flask 控制台直接对接的“外部 API”）

下文的 /api/v1/... 以“Flask 对前端暴露的 API”为准。Flask 内部如何转发到 scheduler/orchestrator，可按你的实现选择（转发/直连 DB/混合）。

4.1 认证与幂等

Header：Authorization: Bearer <JWT>

幂等（强烈建议用于“手动触发 Run”）：

Idempotency-Key: <uuid>

同 Key + 同用户 + 同请求体 → 返回同一 run_id

5. Workflow（DAG）相关接口（用于可视化选择、展示 DAG 图）
5.1 列表
GET /api/v1/workflows?search=&limit=&cursor=

返回（示例）：

{
  "items": [
    {
      "workflow_id": "build_pipeline",
      "name": "Build Pipeline",
      "latest_version": "v12",
      "tags": ["ci"],
      "updated_at": "..."
    }
  ],
  "next_cursor": null
}

5.2 详情（含参数 schema）
GET /api/v1/workflows/{workflow_id}
{
  "workflow_id": "build_pipeline",
  "name": "Build Pipeline",
  "versions": ["v10","v11","v12"],
  "default_version": "v12",
  "params_schema": {
    "type": "object",
    "properties": {
      "branch": {"type":"string","default":"main"},
      "fast": {"type":"boolean","default":false}
    }
  }
}

5.3 DAG 图（用于前端画拓扑）
GET /api/v1/workflows/{workflow_id}/graph?version=v12
{
  "nodes": [
    {"node_id":"checkout","name":"Checkout","type":"task"},
    {"node_id":"build","name":"Build","type":"task"}
  ],
  "edges": [
    {"from":"checkout","to":"build"}
  ]
}

6. Schedule（Cron 可视化配置）接口 —— 替代“内置 Cron”
6.1 Schedule 数据结构（建议）
{
  "schedule_id": "daily_build_3am",
  "name": "Daily Build 3AM",
  "enabled": true,

  "workflow_ref": {
    "workflow_id": "build_pipeline",
    "version": "v12"  
  },

  "schedule": {
    "cron": "0 3 * * *",
    "timezone": "Asia/Shanghai"
  },

  "trigger_policy": {
    "misfire": "run_once",
    "jitter_sec": 60
  },

  "run_policy": {
    "concurrency": {
      "mode": "forbid",
      "key": "build_pipeline_daily"
    },
    "timeout_sec": 1800,
    "retry": {"times": 2, "backoff_sec": [10, 30]},
    "queue": {"mode": "coalesce"} 
  },

  "params_template": {
    "branch": "main",
    "fast": false
  },

  "revision": 7,
  "next_fire_at": "..."
}

说明

workflow_ref：调度绑定到某个 workflow/version（版本化非常关键）

params_template：Schedule 触发 Run 时的默认参数（前端可编辑表单）

revision：并发编辑保护（更新必须携带）

next_fire_at：列表展示用（后端计算返回，前端无需自己算）

6.2 列表
GET /api/v1/schedules?enabled=&workflow_id=&search=&limit=&cursor=
6.3 详情
GET /api/v1/schedules/{schedule_id}
6.4 创建
POST /api/v1/schedules

返回：

{"schedule_id":"daily_build_3am","revision":1}

6.5 更新（带 revision）
PUT /api/v1/schedules/{schedule_id}

请求体必须带 revision，不匹配返回 409 revision_conflict：

{"error":"revision_conflict","current_revision":8}

6.6 启用/禁用
POST /api/v1/schedules/{schedule_id}:enable
POST /api/v1/schedules/{schedule_id}:disable
6.7 删除
DELETE /api/v1/schedules/{schedule_id}
7. Cron 校验与预览（编辑器必备）
POST /api/v1/cron/validate
{"cron":"0 3 * * *","timezone":"Asia/Shanghai"}

POST /api/v1/cron/preview
{"cron":"*/15 * * * *","timezone":"Asia/Shanghai","count":10}

8. Run（DAG 执行实例）接口 —— 可视化控制核心
8.1 手动触发 Run（不经过 cron）
POST /api/v1/workflows/{workflow_id}:runNow
{
  "version": "v12",
  "params": {"branch":"main","fast":true},
  "reason": "manual_trigger"
}


返回：

{"run_id":"run_20260207_0001","status":"scheduled"}

8.2 从 Schedule 立即触发一次（复用 params_template，可覆盖）
POST /api/v1/schedules/{schedule_id}:runNow
{"params_override":{"branch":"hotfix"},"reason":"manual_trigger"}

8.3 查询 Run
GET /api/v1/runs?workflow_id=&schedule_id=&status=&limit=&cursor=
GET /api/v1/runs/{run_id}

（含 summary，便于详情页渲染）

{
  "run_id": "run_...",
  "workflow_id": "build_pipeline",
  "version": "v12",
  "schedule_id": "daily_build_3am",
  "status": "running",
  "scheduled_at": "...",
  "started_at": "...",
  "heartbeat_at": "...",
  "progress": {
    "done_nodes": 3,
    "total_nodes": 10,
    "stage": "build"
  },
  "summary": null
}

8.4 取消/暂停/恢复
POST /api/v1/runs/{run_id}:cancel

语义：停止当前 Run，尽量优雅终止；必要时强杀。

POST /api/v1/runs/{run_id}:pause

语义建议：不再调度新的 NodeRun；已运行的节点可选择：

graceful=true：允许当前运行节点自然结束

graceful=false：直接中断正在运行的节点（更强控制）

POST /api/v1/runs/{run_id}:resume

语义：恢复调度剩余节点。

8.5 重试（Run 级别）
POST /api/v1/runs/{run_id}:retry

语义：对失败的节点按策略重试，或重新跑整条 DAG（由参数控制）

{"mode":"failed_only"} 

9. NodeRun 接口（节点级可视化控制：重试/跳过/查看日志）
9.1 列出某次 Run 的节点状态（用于 DAG 图上挂状态）
GET /api/v1/runs/{run_id}/nodeRuns

返回：

{
  "items":[
    {"node_run_id":"nr_1","node_id":"checkout","status":"success","attempt":1,"started_at":"...","finished_at":"..."},
    {"node_run_id":"nr_2","node_id":"build","status":"running","attempt":1,"started_at":"..."}
  ]
}

9.2 节点详情
GET /api/v1/nodeRuns/{node_run_id}
9.3 节点控制
POST /api/v1/nodeRuns/{node_run_id}:retry
POST /api/v1/nodeRuns/{node_run_id}:cancel
POST /api/v1/nodeRuns/{node_run_id}:skip

skip 需要非常明确的审计与权限（建议 admin/editor + 强提示）

10. 日志与进度（对接 OpenClawd“定时汇报/完成总结”）
10.1 Run 日志（分页）
GET /api/v1/runs/{run_id}/log?since_seq=1234&limit=500
{"items":[{"seq":1234,"ts":"...","level":"info","source":"node:build","msg":"..."}],"next_seq":1300}

10.2 NodeRun 日志
GET /api/v1/nodeRuns/{node_run_id}/log?since_seq=&limit=
10.3 完成总结（summary）

包含：

触发时间 vs 实际开始时间

耗时、退出原因

失败节点列表、最后错误

stdout/stderr tail（或结构化日志 tail）

11. 事件流（SSE）—— 让控制台“实时刷新”，避免轮询
11.1 订阅
GET /api/v1/events?workflow_id=&run_id=&schedule_id=

返回 SSE 流事件，建议事件类型：

schedule.updated

run.scheduled | run.started | run.progress | run.finished | run.failed | run.canceled | run.timeout

nodeRun.started | nodeRun.progress | nodeRun.finished | nodeRun.failed

（可选）log.append

事件载荷建议（统一 envelope）
{
  "type": "nodeRun.progress",
  "ts": "...",
  "run_id": "run_...",
  "node_run_id": "nr_2",
  "payload": { "percent": 40, "hint": "compiling" }
}


Flask 实现上，你可以：

前端连 Flask /events

Flask 再去 scheduler/orchestrator 订阅内部事件（或读 DB+notify）并转发

12. 状态机（前端交互必须明确）
12.1 Run 状态建议

scheduled → running → success|failed|timeout|canceled

running → paused → running

running → lost（心跳超时，执行器失联）

12.2 NodeRun 状态建议

queued → running → success|failed|canceled|skipped

这些状态直接决定 UI 上按钮是否可点、以及“重试/跳过”的合法性。

13. Flask 后端实现建议（不写大段代码，只给关键点）
13.1 BFF 的“聚合职责”

鉴权/RBAC：统一在 Flask 做

审计：对 enable/disable/runNow/cancel/skip 等写操作记录 who/when/what

统一错误码：将 scheduler/orchestrator 的内部错误映射成稳定的 API 错误

13.2 与 scheduler/orchestrator 的内部连接

若走 Unix Socket：Flask 侧使用支持 unix socket 的 HTTP client（实现层你自行选库）

超时策略：

写操作（创建/更新/取消）：短超时（2–5s）

日志/事件流：长连接（SSE），需要心跳（每 15–30s 发注释行）